{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { BaseWalletAdapter } from './adapter';\nimport { WalletError, WalletSendTransactionError } from './errors';\nexport class BaseSignerWalletAdapter extends BaseWalletAdapter {\n  sendTransaction(transaction, connection) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      let emit = true;\n\n      try {\n        try {\n          transaction.feePayer || (transaction.feePayer = this.publicKey || undefined);\n          transaction.recentBlockhash || (transaction.recentBlockhash = (yield connection.getRecentBlockhash('finalized')).blockhash);\n\n          const {\n            signers\n          } = options,\n                sendOptions = __rest(options, [\"signers\"]);\n\n          (signers === null || signers === void 0 ? void 0 : signers.length) && transaction.partialSign(...signers);\n          transaction = yield this.signTransaction(transaction);\n          const rawTransaction = transaction.serialize();\n          return yield connection.sendRawTransaction(rawTransaction, sendOptions);\n        } catch (error) {\n          // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event\n          if (error instanceof WalletError) {\n            emit = false;\n            throw error;\n          }\n\n          throw new WalletSendTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n        }\n      } catch (error) {\n        if (emit) {\n          this.emit('error', error);\n        }\n\n        throw error;\n      }\n    });\n  }\n\n}\nexport class BaseMessageSignerWalletAdapter extends BaseSignerWalletAdapter {}","map":{"version":3,"sources":["../src/signer.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,SAAS,iBAAT,QAAyE,WAAzE;AACA,SAAS,WAAT,EAAsB,0BAAtB,QAAwD,UAAxD;AASA,OAAM,MAAgB,uBAAhB,SAAgD,iBAAhD,CAAiE;AAC7D,EAAA,eAAe,CACjB,WADiB,EAEjB,UAFiB,EAGmB;AAAA,QAApC,OAAoC,uEAAF,EAAE;;AAEpC,UAAI,IAAI,GAAG,IAAX;;AACA,UAAI;AACA,YAAI;AACA,UAAA,WAAW,CAAC,QAAZ,KAAA,WAAW,CAAC,QAAZ,GAAyB,KAAK,SAAL,IAAkB,SAA3C;AACA,UAAA,WAAW,CAAC,eAAZ,KAAA,WAAW,CAAC,eAAZ,GAAgC,CAAC,MAAM,UAAU,CAAC,kBAAX,CAA8B,WAA9B,CAAP,EAAmD,SAAnF;;AAEA,gBAAM;AAAE,YAAA;AAAF,cAA8B,OAApC;AAAA,gBAAoB,WAAW,GAAA,MAAA,CAAK,OAAL,EAAzB,CAAA,SAAA,CAAyB,CAA/B;;AAEA,WAAA,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAO,KAAA,CAAP,GAAA,OAAO,CAAE,MAAT,KAAmB,WAAW,CAAC,WAAZ,CAAwB,GAAG,OAA3B,CAAnB;AAEA,UAAA,WAAW,GAAG,MAAM,KAAK,eAAL,CAAqB,WAArB,CAApB;AAEA,gBAAM,cAAc,GAAG,WAAW,CAAC,SAAZ,EAAvB;AAEA,iBAAO,MAAM,UAAU,CAAC,kBAAX,CAA8B,cAA9B,EAA8C,WAA9C,CAAb;AACH,SAbD,CAaE,OAAO,KAAP,EAAmB;AACjB;AACA,cAAI,KAAK,YAAY,WAArB,EAAkC;AAC9B,YAAA,IAAI,GAAG,KAAP;AACA,kBAAM,KAAN;AACH;;AACD,gBAAM,IAAI,0BAAJ,CAA+B,KAAK,KAAA,IAAL,IAAA,KAAK,KAAA,KAAA,CAAL,GAAK,KAAA,CAAL,GAAA,KAAK,CAAE,OAAtC,EAA+C,KAA/C,CAAN;AACH;AACJ,OAtBD,CAsBE,OAAO,KAAP,EAAmB;AACjB,YAAI,IAAJ,EAAU;AACN,eAAK,IAAL,CAAU,OAAV,EAAmB,KAAnB;AACH;;AACD,cAAM,KAAN;AACH;AACJ,K;AAAA;;AAnCkE;AA+CvE,OAAM,MAAgB,8BAAhB,SACM,uBADN,CAC6B","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { BaseWalletAdapter } from './adapter';\nimport { WalletError, WalletSendTransactionError } from './errors';\nexport class BaseSignerWalletAdapter extends BaseWalletAdapter {\n    sendTransaction(transaction, connection, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let emit = true;\n            try {\n                try {\n                    transaction.feePayer || (transaction.feePayer = this.publicKey || undefined);\n                    transaction.recentBlockhash || (transaction.recentBlockhash = (yield connection.getRecentBlockhash('finalized')).blockhash);\n                    const { signers } = options, sendOptions = __rest(options, [\"signers\"]);\n                    (signers === null || signers === void 0 ? void 0 : signers.length) && transaction.partialSign(...signers);\n                    transaction = yield this.signTransaction(transaction);\n                    const rawTransaction = transaction.serialize();\n                    return yield connection.sendRawTransaction(rawTransaction, sendOptions);\n                }\n                catch (error) {\n                    // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event\n                    if (error instanceof WalletError) {\n                        emit = false;\n                        throw error;\n                    }\n                    throw new WalletSendTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n                }\n            }\n            catch (error) {\n                if (emit) {\n                    this.emit('error', error);\n                }\n                throw error;\n            }\n        });\n    }\n}\nexport class BaseMessageSignerWalletAdapter extends BaseSignerWalletAdapter {\n}\n//# sourceMappingURL=signer.js.map"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import camelCase from \"camelcase\";\nimport EventEmitter from \"eventemitter3\";\nimport * as bs58 from \"bs58\";\nimport { SystemProgram } from \"@solana/web3.js\";\nimport Coder, { ACCOUNT_DISCRIMINATOR_SIZE, accountSize, AccountsCoder } from \"../../coder\";\nimport { translateAddress } from \"../common\";\nimport { getProvider } from \"../../\";\nimport * as pubkeyUtil from \"../../utils/pubkey\";\nimport * as rpcUtil from \"../../utils/rpc\";\nexport default class AccountFactory {\n  static build(idl, coder, programId, provider) {\n    var _a;\n\n    const accountFns = {};\n    (_a = idl.accounts) === null || _a === void 0 ? void 0 : _a.forEach(idlAccount => {\n      const name = camelCase(idlAccount.name);\n      accountFns[name] = new AccountClient(idl, idlAccount, programId, provider, coder);\n    });\n    return accountFns;\n  }\n\n}\nexport class AccountClient {\n  constructor(idl, idlAccount, programId, provider, coder) {\n    var _a;\n\n    this._idlAccount = idlAccount;\n    this._programId = programId;\n    this._provider = provider !== null && provider !== void 0 ? provider : getProvider();\n    this._coder = coder !== null && coder !== void 0 ? coder : new Coder(idl);\n    this._size = ACCOUNT_DISCRIMINATOR_SIZE + ((_a = accountSize(idl, idlAccount)) !== null && _a !== void 0 ? _a : 0);\n  }\n  /**\n   * Returns the number of bytes in this account.\n   */\n\n\n  get size() {\n    return this._size;\n  }\n  /**\n   * Returns the program ID owning all accounts.\n   */\n\n\n  get programId() {\n    return this._programId;\n  }\n  /**\n   * Returns the client's wallet and network provider.\n   */\n\n\n  get provider() {\n    return this._provider;\n  }\n  /**\n   * Returns the coder.\n   */\n\n\n  get coder() {\n    return this._coder;\n  }\n  /**\n   * Returns a deserialized account, returning null if it doesn't exist.\n   *\n   * @param address The address of the account to fetch.\n   */\n\n\n  async fetchNullable(address) {\n    const accountInfo = await this._provider.connection.getAccountInfo(translateAddress(address));\n\n    if (accountInfo === null) {\n      return null;\n    } // Assert the account discriminator is correct.\n\n\n    const discriminator = AccountsCoder.accountDiscriminator(this._idlAccount.name);\n\n    if (discriminator.compare(accountInfo.data.slice(0, 8))) {\n      throw new Error(\"Invalid account discriminator\");\n    }\n\n    return this._coder.accounts.decode(this._idlAccount.name, accountInfo.data);\n  }\n  /**\n   * Returns a deserialized account.\n   *\n   * @param address The address of the account to fetch.\n   */\n\n\n  async fetch(address) {\n    const data = await this.fetchNullable(address);\n\n    if (data === null) {\n      throw new Error(`Account does not exist ${address.toString()}`);\n    }\n\n    return data;\n  }\n  /**\n   * Returns multiple deserialized accounts.\n   * Accounts not found or with wrong discriminator are returned as null.\n   *\n   * @param addresses The addresses of the accounts to fetch.\n   */\n\n\n  async fetchMultiple(addresses) {\n    const accounts = await rpcUtil.getMultipleAccounts(this._provider.connection, addresses.map(address => translateAddress(address)));\n    const discriminator = AccountsCoder.accountDiscriminator(this._idlAccount.name); // Decode accounts where discriminator is correct, null otherwise\n\n    return accounts.map(account => {\n      if (account == null) {\n        return null;\n      }\n\n      if (discriminator.compare(account === null || account === void 0 ? void 0 : account.account.data.slice(0, 8))) {\n        return null;\n      }\n\n      return this._coder.accounts.decode(this._idlAccount.name, account === null || account === void 0 ? void 0 : account.account.data);\n    });\n  }\n  /**\n   * Returns all instances of this account type for the program.\n   *\n   * @param filters User-provided filters to narrow the results from `connection.getProgramAccounts`.\n   *\n   *                When filters are not defined this method returns all\n   *                the account instances.\n   *\n   *                When filters are of type `Buffer`, the filters are appended\n   *                after the discriminator.\n   *\n   *                When filters are of type `GetProgramAccountsFilter[]`,\n   *                filters are appended after the discriminator filter.\n   */\n\n\n  async all(filters) {\n    const discriminator = AccountsCoder.accountDiscriminator(this._idlAccount.name);\n    let resp = await this._provider.connection.getProgramAccounts(this._programId, {\n      commitment: this._provider.connection.commitment,\n      filters: [{\n        memcmp: {\n          offset: 0,\n          bytes: bs58.encode(filters instanceof Buffer ? Buffer.concat([discriminator, filters]) : discriminator)\n        }\n      }, ...(Array.isArray(filters) ? filters : [])]\n    });\n    return resp.map(_ref => {\n      let {\n        pubkey,\n        account\n      } = _ref;\n      return {\n        publicKey: pubkey,\n        account: this._coder.accounts.decode(this._idlAccount.name, account.data)\n      };\n    });\n  }\n  /**\n   * Returns an `EventEmitter` emitting a \"change\" event whenever the account\n   * changes.\n   */\n\n\n  subscribe(address, commitment) {\n    const sub = subscriptions.get(address.toString());\n\n    if (sub) {\n      return sub.ee;\n    }\n\n    const ee = new EventEmitter();\n    address = translateAddress(address);\n\n    const listener = this._provider.connection.onAccountChange(address, acc => {\n      const account = this._coder.accounts.decode(this._idlAccount.name, acc.data);\n\n      ee.emit(\"change\", account);\n    }, commitment);\n\n    subscriptions.set(address.toString(), {\n      ee,\n      listener\n    });\n    return ee;\n  }\n  /**\n   * Unsubscribes from the account at the given address.\n   */\n\n\n  async unsubscribe(address) {\n    let sub = subscriptions.get(address.toString());\n\n    if (!sub) {\n      console.warn(\"Address is not subscribed\");\n      return;\n    }\n\n    if (subscriptions) {\n      await this._provider.connection.removeAccountChangeListener(sub.listener).then(() => {\n        subscriptions.delete(address.toString());\n      }).catch(console.error);\n    }\n  }\n  /**\n   * Returns an instruction for creating this account.\n   */\n\n\n  async createInstruction(signer, sizeOverride) {\n    const size = this.size;\n    return SystemProgram.createAccount({\n      fromPubkey: this._provider.wallet.publicKey,\n      newAccountPubkey: signer.publicKey,\n      space: sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size,\n      lamports: await this._provider.connection.getMinimumBalanceForRentExemption(sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size),\n      programId: this._programId\n    });\n  }\n  /**\n   * @deprecated since version 14.0.\n   *\n   * Function returning the associated account. Args are keys to associate.\n   * Order matters.\n   */\n\n\n  async associated() {\n    const addr = await this.associatedAddress(...arguments);\n    return await this.fetch(addr);\n  }\n  /**\n   * @deprecated since version 14.0.\n   *\n   * Function returning the associated address. Args are keys to associate.\n   * Order matters.\n   */\n\n\n  async associatedAddress() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return await pubkeyUtil.associated(this._programId, ...args);\n  }\n\n} // Tracks all subscriptions.\n\nconst subscriptions = new Map();","map":{"version":3,"sources":["../../../../src/program/namespace/account.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import camelCase from \"camelcase\";\nimport EventEmitter from \"eventemitter3\";\nimport * as bs58 from \"bs58\";\nimport { SystemProgram, } from \"@solana/web3.js\";\nimport Coder, { ACCOUNT_DISCRIMINATOR_SIZE, accountSize, AccountsCoder, } from \"../../coder\";\nimport { translateAddress } from \"../common\";\nimport { getProvider } from \"../../\";\nimport * as pubkeyUtil from \"../../utils/pubkey\";\nimport * as rpcUtil from \"../../utils/rpc\";\nexport default class AccountFactory {\n    static build(idl, coder, programId, provider) {\n        var _a;\n        const accountFns = {};\n        (_a = idl.accounts) === null || _a === void 0 ? void 0 : _a.forEach((idlAccount) => {\n            const name = camelCase(idlAccount.name);\n            accountFns[name] = new AccountClient(idl, idlAccount, programId, provider, coder);\n        });\n        return accountFns;\n    }\n}\nexport class AccountClient {\n    constructor(idl, idlAccount, programId, provider, coder) {\n        var _a;\n        this._idlAccount = idlAccount;\n        this._programId = programId;\n        this._provider = provider !== null && provider !== void 0 ? provider : getProvider();\n        this._coder = coder !== null && coder !== void 0 ? coder : new Coder(idl);\n        this._size =\n            ACCOUNT_DISCRIMINATOR_SIZE + ((_a = accountSize(idl, idlAccount)) !== null && _a !== void 0 ? _a : 0);\n    }\n    /**\n     * Returns the number of bytes in this account.\n     */\n    get size() {\n        return this._size;\n    }\n    /**\n     * Returns the program ID owning all accounts.\n     */\n    get programId() {\n        return this._programId;\n    }\n    /**\n     * Returns the client's wallet and network provider.\n     */\n    get provider() {\n        return this._provider;\n    }\n    /**\n     * Returns the coder.\n     */\n    get coder() {\n        return this._coder;\n    }\n    /**\n     * Returns a deserialized account, returning null if it doesn't exist.\n     *\n     * @param address The address of the account to fetch.\n     */\n    async fetchNullable(address) {\n        const accountInfo = await this._provider.connection.getAccountInfo(translateAddress(address));\n        if (accountInfo === null) {\n            return null;\n        }\n        // Assert the account discriminator is correct.\n        const discriminator = AccountsCoder.accountDiscriminator(this._idlAccount.name);\n        if (discriminator.compare(accountInfo.data.slice(0, 8))) {\n            throw new Error(\"Invalid account discriminator\");\n        }\n        return this._coder.accounts.decode(this._idlAccount.name, accountInfo.data);\n    }\n    /**\n     * Returns a deserialized account.\n     *\n     * @param address The address of the account to fetch.\n     */\n    async fetch(address) {\n        const data = await this.fetchNullable(address);\n        if (data === null) {\n            throw new Error(`Account does not exist ${address.toString()}`);\n        }\n        return data;\n    }\n    /**\n     * Returns multiple deserialized accounts.\n     * Accounts not found or with wrong discriminator are returned as null.\n     *\n     * @param addresses The addresses of the accounts to fetch.\n     */\n    async fetchMultiple(addresses) {\n        const accounts = await rpcUtil.getMultipleAccounts(this._provider.connection, addresses.map((address) => translateAddress(address)));\n        const discriminator = AccountsCoder.accountDiscriminator(this._idlAccount.name);\n        // Decode accounts where discriminator is correct, null otherwise\n        return accounts.map((account) => {\n            if (account == null) {\n                return null;\n            }\n            if (discriminator.compare(account === null || account === void 0 ? void 0 : account.account.data.slice(0, 8))) {\n                return null;\n            }\n            return this._coder.accounts.decode(this._idlAccount.name, account === null || account === void 0 ? void 0 : account.account.data);\n        });\n    }\n    /**\n     * Returns all instances of this account type for the program.\n     *\n     * @param filters User-provided filters to narrow the results from `connection.getProgramAccounts`.\n     *\n     *                When filters are not defined this method returns all\n     *                the account instances.\n     *\n     *                When filters are of type `Buffer`, the filters are appended\n     *                after the discriminator.\n     *\n     *                When filters are of type `GetProgramAccountsFilter[]`,\n     *                filters are appended after the discriminator filter.\n     */\n    async all(filters) {\n        const discriminator = AccountsCoder.accountDiscriminator(this._idlAccount.name);\n        let resp = await this._provider.connection.getProgramAccounts(this._programId, {\n            commitment: this._provider.connection.commitment,\n            filters: [\n                {\n                    memcmp: {\n                        offset: 0,\n                        bytes: bs58.encode(filters instanceof Buffer\n                            ? Buffer.concat([discriminator, filters])\n                            : discriminator),\n                    },\n                },\n                ...(Array.isArray(filters) ? filters : []),\n            ],\n        });\n        return resp.map(({ pubkey, account }) => {\n            return {\n                publicKey: pubkey,\n                account: this._coder.accounts.decode(this._idlAccount.name, account.data),\n            };\n        });\n    }\n    /**\n     * Returns an `EventEmitter` emitting a \"change\" event whenever the account\n     * changes.\n     */\n    subscribe(address, commitment) {\n        const sub = subscriptions.get(address.toString());\n        if (sub) {\n            return sub.ee;\n        }\n        const ee = new EventEmitter();\n        address = translateAddress(address);\n        const listener = this._provider.connection.onAccountChange(address, (acc) => {\n            const account = this._coder.accounts.decode(this._idlAccount.name, acc.data);\n            ee.emit(\"change\", account);\n        }, commitment);\n        subscriptions.set(address.toString(), {\n            ee,\n            listener,\n        });\n        return ee;\n    }\n    /**\n     * Unsubscribes from the account at the given address.\n     */\n    async unsubscribe(address) {\n        let sub = subscriptions.get(address.toString());\n        if (!sub) {\n            console.warn(\"Address is not subscribed\");\n            return;\n        }\n        if (subscriptions) {\n            await this._provider.connection\n                .removeAccountChangeListener(sub.listener)\n                .then(() => {\n                subscriptions.delete(address.toString());\n            })\n                .catch(console.error);\n        }\n    }\n    /**\n     * Returns an instruction for creating this account.\n     */\n    async createInstruction(signer, sizeOverride) {\n        const size = this.size;\n        return SystemProgram.createAccount({\n            fromPubkey: this._provider.wallet.publicKey,\n            newAccountPubkey: signer.publicKey,\n            space: sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size,\n            lamports: await this._provider.connection.getMinimumBalanceForRentExemption(sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size),\n            programId: this._programId,\n        });\n    }\n    /**\n     * @deprecated since version 14.0.\n     *\n     * Function returning the associated account. Args are keys to associate.\n     * Order matters.\n     */\n    async associated(...args) {\n        const addr = await this.associatedAddress(...args);\n        return await this.fetch(addr);\n    }\n    /**\n     * @deprecated since version 14.0.\n     *\n     * Function returning the associated address. Args are keys to associate.\n     * Order matters.\n     */\n    async associatedAddress(...args) {\n        return await pubkeyUtil.associated(this._programId, ...args);\n    }\n}\n// Tracks all subscriptions.\nconst subscriptions = new Map();\n//# sourceMappingURL=account.js.map"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import * as assert from \"assert\";\nconst LOG_START_INDEX = \"Program log: \".length;\nexport class EventManager {\n  constructor(programId, provider, coder) {\n    this._programId = programId;\n    this._provider = provider;\n    this._eventParser = new EventParser(programId, coder);\n    this._eventCallbacks = new Map();\n    this._eventListeners = new Map();\n    this._listenerIdCount = 0;\n  }\n\n  addEventListener(eventName, callback) {\n    var _a;\n\n    let listener = this._listenerIdCount;\n    this._listenerIdCount += 1; // Store the listener into the event map.\n\n    if (!(eventName in this._eventCallbacks)) {\n      this._eventListeners.set(eventName, []);\n    }\n\n    this._eventListeners.set(eventName, ((_a = this._eventListeners.get(eventName)) !== null && _a !== void 0 ? _a : []).concat(listener)); // Store the callback into the listener map.\n\n\n    this._eventCallbacks.set(listener, [eventName, callback]); // Create the subscription singleton, if needed.\n\n\n    if (this._onLogsSubscriptionId !== undefined) {\n      return listener;\n    }\n\n    this._onLogsSubscriptionId = this._provider.connection.onLogs(this._programId, (logs, ctx) => {\n      if (logs.err) {\n        console.error(logs);\n        return;\n      }\n\n      this._eventParser.parseLogs(logs.logs, event => {\n        const allListeners = this._eventListeners.get(event.name);\n\n        if (allListeners) {\n          allListeners.forEach(listener => {\n            const listenerCb = this._eventCallbacks.get(listener);\n\n            if (listenerCb) {\n              const [, callback] = listenerCb;\n              callback(event.data, ctx.slot);\n            }\n          });\n        }\n      });\n    });\n    return listener;\n  }\n\n  async removeEventListener(listener) {\n    // Get the callback.\n    const callback = this._eventCallbacks.get(listener);\n\n    if (!callback) {\n      throw new Error(`Event listener ${listener} doesn't exist!`);\n    }\n\n    const [eventName] = callback; // Get the listeners.\n\n    let listeners = this._eventListeners.get(eventName);\n\n    if (!listeners) {\n      throw new Error(`Event listeners don't exist for ${eventName}!`);\n    } // Update both maps.\n\n\n    this._eventCallbacks.delete(listener);\n\n    listeners = listeners.filter(l => l !== listener);\n\n    if (listeners.length === 0) {\n      this._eventListeners.delete(eventName);\n    } // Kill the websocket connection if all listeners have been removed.\n\n\n    if (this._eventCallbacks.size == 0) {\n      assert.ok(this._eventListeners.size === 0);\n\n      if (this._onLogsSubscriptionId !== undefined) {\n        await this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId);\n        this._onLogsSubscriptionId = undefined;\n      }\n    }\n  }\n\n}\nexport class EventParser {\n  constructor(programId, coder) {\n    this.coder = coder;\n    this.programId = programId;\n  } // Each log given, represents an array of messages emitted by\n  // a single transaction, which can execute many different programs across\n  // CPI boundaries. However, the subscription is only interested in the\n  // events emitted by *this* program. In achieving this, we keep track of the\n  // program execution context by parsing each log and looking for a CPI\n  // `invoke` call. If one exists, we know a new program is executing. So we\n  // push the programId onto a stack and switch the program context. This\n  // allows us to track, for a given log, which program was executing during\n  // its emission, thereby allowing us to know if a given log event was\n  // emitted by *this* program. If it was, then we parse the raw string and\n  // emit the event if the string matches the event being subscribed to.\n\n\n  parseLogs(logs, callback) {\n    const logScanner = new LogScanner(logs);\n    const execution = new ExecutionContext(logScanner.next());\n    let log = logScanner.next();\n\n    while (log !== null) {\n      let [event, newProgram, didPop] = this.handleLog(execution, log);\n\n      if (event) {\n        callback(event);\n      }\n\n      if (newProgram) {\n        execution.push(newProgram);\n      }\n\n      if (didPop) {\n        execution.pop();\n      }\n\n      log = logScanner.next();\n    }\n  } // Main log handler. Returns a three element array of the event, the\n  // next program that was invoked for CPI, and a boolean indicating if\n  // a program has completed execution (and thus should be popped off the\n  // execution stack).\n\n\n  handleLog(execution, log) {\n    // Executing program is this program.\n    if (execution.stack.length > 0 && execution.program() === this.programId.toString()) {\n      return this.handleProgramLog(log);\n    } // Executing program is not this program.\n    else {\n      return [null, ...this.handleSystemLog(log)];\n    }\n  } // Handles logs from *this* program.\n\n\n  handleProgramLog(log) {\n    // This is a `msg!` log.\n    if (log.startsWith(\"Program log:\")) {\n      const logStr = log.slice(LOG_START_INDEX);\n      const event = this.coder.events.decode(logStr);\n      return [event, null, false];\n    } // System log.\n    else {\n      return [null, ...this.handleSystemLog(log)];\n    }\n  } // Handles logs when the current program being executing is *not* this.\n\n\n  handleSystemLog(log) {\n    // System component.\n    const logStart = log.split(\":\")[0]; // Did the program finish executing?\n\n    if (logStart.match(/^Program (.*) success/g) !== null) {\n      return [null, true]; // Recursive call.\n    } else if (logStart.startsWith(`Program ${this.programId.toString()} invoke`)) {\n      return [this.programId.toString(), false];\n    } // CPI call.\n    else if (logStart.includes(\"invoke\")) {\n      return [\"cpi\", false]; // Any string will do.\n    } else {\n      return [null, false];\n    }\n  }\n\n} // Stack frame execution context, allowing one to track what program is\n// executing for a given log.\n\nclass ExecutionContext {\n  constructor(log) {\n    var _a; // Assumes the first log in every transaction is an `invoke` log from the\n    // runtime.\n\n\n    const program = (_a = /^Program (.*) invoke.*$/g.exec(log)) === null || _a === void 0 ? void 0 : _a[1];\n\n    if (!program) {\n      throw new Error(`Could not find program invocation log line`);\n    }\n\n    this.stack = [program];\n  }\n\n  program() {\n    assert.ok(this.stack.length > 0);\n    return this.stack[this.stack.length - 1];\n  }\n\n  push(newProgram) {\n    this.stack.push(newProgram);\n  }\n\n  pop() {\n    assert.ok(this.stack.length > 0);\n    this.stack.pop();\n  }\n\n}\n\nclass LogScanner {\n  constructor(logs) {\n    this.logs = logs;\n  }\n\n  next() {\n    if (this.logs.length === 0) {\n      return null;\n    }\n\n    let l = this.logs[0];\n    this.logs = this.logs.slice(1);\n    return l;\n  }\n\n}","map":{"version":3,"sources":["../../../src/program/event.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as assert from \"assert\";\nconst LOG_START_INDEX = \"Program log: \".length;\nexport class EventManager {\n    constructor(programId, provider, coder) {\n        this._programId = programId;\n        this._provider = provider;\n        this._eventParser = new EventParser(programId, coder);\n        this._eventCallbacks = new Map();\n        this._eventListeners = new Map();\n        this._listenerIdCount = 0;\n    }\n    addEventListener(eventName, callback) {\n        var _a;\n        let listener = this._listenerIdCount;\n        this._listenerIdCount += 1;\n        // Store the listener into the event map.\n        if (!(eventName in this._eventCallbacks)) {\n            this._eventListeners.set(eventName, []);\n        }\n        this._eventListeners.set(eventName, ((_a = this._eventListeners.get(eventName)) !== null && _a !== void 0 ? _a : []).concat(listener));\n        // Store the callback into the listener map.\n        this._eventCallbacks.set(listener, [eventName, callback]);\n        // Create the subscription singleton, if needed.\n        if (this._onLogsSubscriptionId !== undefined) {\n            return listener;\n        }\n        this._onLogsSubscriptionId = this._provider.connection.onLogs(this._programId, (logs, ctx) => {\n            if (logs.err) {\n                console.error(logs);\n                return;\n            }\n            this._eventParser.parseLogs(logs.logs, (event) => {\n                const allListeners = this._eventListeners.get(event.name);\n                if (allListeners) {\n                    allListeners.forEach((listener) => {\n                        const listenerCb = this._eventCallbacks.get(listener);\n                        if (listenerCb) {\n                            const [, callback] = listenerCb;\n                            callback(event.data, ctx.slot);\n                        }\n                    });\n                }\n            });\n        });\n        return listener;\n    }\n    async removeEventListener(listener) {\n        // Get the callback.\n        const callback = this._eventCallbacks.get(listener);\n        if (!callback) {\n            throw new Error(`Event listener ${listener} doesn't exist!`);\n        }\n        const [eventName] = callback;\n        // Get the listeners.\n        let listeners = this._eventListeners.get(eventName);\n        if (!listeners) {\n            throw new Error(`Event listeners don't exist for ${eventName}!`);\n        }\n        // Update both maps.\n        this._eventCallbacks.delete(listener);\n        listeners = listeners.filter((l) => l !== listener);\n        if (listeners.length === 0) {\n            this._eventListeners.delete(eventName);\n        }\n        // Kill the websocket connection if all listeners have been removed.\n        if (this._eventCallbacks.size == 0) {\n            assert.ok(this._eventListeners.size === 0);\n            if (this._onLogsSubscriptionId !== undefined) {\n                await this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId);\n                this._onLogsSubscriptionId = undefined;\n            }\n        }\n    }\n}\nexport class EventParser {\n    constructor(programId, coder) {\n        this.coder = coder;\n        this.programId = programId;\n    }\n    // Each log given, represents an array of messages emitted by\n    // a single transaction, which can execute many different programs across\n    // CPI boundaries. However, the subscription is only interested in the\n    // events emitted by *this* program. In achieving this, we keep track of the\n    // program execution context by parsing each log and looking for a CPI\n    // `invoke` call. If one exists, we know a new program is executing. So we\n    // push the programId onto a stack and switch the program context. This\n    // allows us to track, for a given log, which program was executing during\n    // its emission, thereby allowing us to know if a given log event was\n    // emitted by *this* program. If it was, then we parse the raw string and\n    // emit the event if the string matches the event being subscribed to.\n    parseLogs(logs, callback) {\n        const logScanner = new LogScanner(logs);\n        const execution = new ExecutionContext(logScanner.next());\n        let log = logScanner.next();\n        while (log !== null) {\n            let [event, newProgram, didPop] = this.handleLog(execution, log);\n            if (event) {\n                callback(event);\n            }\n            if (newProgram) {\n                execution.push(newProgram);\n            }\n            if (didPop) {\n                execution.pop();\n            }\n            log = logScanner.next();\n        }\n    }\n    // Main log handler. Returns a three element array of the event, the\n    // next program that was invoked for CPI, and a boolean indicating if\n    // a program has completed execution (and thus should be popped off the\n    // execution stack).\n    handleLog(execution, log) {\n        // Executing program is this program.\n        if (execution.stack.length > 0 &&\n            execution.program() === this.programId.toString()) {\n            return this.handleProgramLog(log);\n        }\n        // Executing program is not this program.\n        else {\n            return [null, ...this.handleSystemLog(log)];\n        }\n    }\n    // Handles logs from *this* program.\n    handleProgramLog(log) {\n        // This is a `msg!` log.\n        if (log.startsWith(\"Program log:\")) {\n            const logStr = log.slice(LOG_START_INDEX);\n            const event = this.coder.events.decode(logStr);\n            return [event, null, false];\n        }\n        // System log.\n        else {\n            return [null, ...this.handleSystemLog(log)];\n        }\n    }\n    // Handles logs when the current program being executing is *not* this.\n    handleSystemLog(log) {\n        // System component.\n        const logStart = log.split(\":\")[0];\n        // Did the program finish executing?\n        if (logStart.match(/^Program (.*) success/g) !== null) {\n            return [null, true];\n            // Recursive call.\n        }\n        else if (logStart.startsWith(`Program ${this.programId.toString()} invoke`)) {\n            return [this.programId.toString(), false];\n        }\n        // CPI call.\n        else if (logStart.includes(\"invoke\")) {\n            return [\"cpi\", false]; // Any string will do.\n        }\n        else {\n            return [null, false];\n        }\n    }\n}\n// Stack frame execution context, allowing one to track what program is\n// executing for a given log.\nclass ExecutionContext {\n    constructor(log) {\n        var _a;\n        // Assumes the first log in every transaction is an `invoke` log from the\n        // runtime.\n        const program = (_a = /^Program (.*) invoke.*$/g.exec(log)) === null || _a === void 0 ? void 0 : _a[1];\n        if (!program) {\n            throw new Error(`Could not find program invocation log line`);\n        }\n        this.stack = [program];\n    }\n    program() {\n        assert.ok(this.stack.length > 0);\n        return this.stack[this.stack.length - 1];\n    }\n    push(newProgram) {\n        this.stack.push(newProgram);\n    }\n    pop() {\n        assert.ok(this.stack.length > 0);\n        this.stack.pop();\n    }\n}\nclass LogScanner {\n    constructor(logs) {\n        this.logs = logs;\n    }\n    next() {\n        if (this.logs.length === 0) {\n            return null;\n        }\n        let l = this.logs[0];\n        this.logs = this.logs.slice(1);\n        return l;\n    }\n}\n//# sourceMappingURL=event.js.map"]},"metadata":{},"sourceType":"module"}
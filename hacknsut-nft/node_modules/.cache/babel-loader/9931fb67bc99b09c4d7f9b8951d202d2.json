{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.reducer = void 0;\n\nconst react_1 = require(\"react\");\n\nconst utils_1 = require(\"../useReducer/utils\");\n\nconst logger_1 = __importDefault(require(\"../logger\"));\n\nconst types_1 = require(\"../types\");\n\nconst tokenUtils_1 = require(\"../utils/tokenUtils\");\n\nconst reducer = (state, action) => {\n  switch (action.type) {\n    case 'refresh_start':\n      {\n        return Object.assign(Object.assign({}, state), {\n          walletPowoInProgress: false,\n          powoFinished: false,\n          powoRequested: undefined,\n          refreshInProgress: true,\n          gatewayStatus: types_1.GatewayStatus.REFRESH_TOKEN_REQUIRED\n        });\n      }\n\n    case 'refresh_status_check':\n      {\n        return Object.assign(Object.assign({}, state), {\n          refreshTokenState: types_1.RefreshTokenState.IN_PROGRESS\n        });\n      }\n\n    case 'refresh_complete':\n      {\n        return Object.assign(Object.assign({}, state), {\n          refreshTokenState: types_1.RefreshTokenState.COMPLETED,\n          gatewayStatus: (0, utils_1.statusFromToken)(state, state.gatewayToken),\n          refreshTimeoutId: undefined,\n          civicPass: Object.assign(Object.assign({}, state.civicPass), {\n            responsePayload: undefined\n          })\n        });\n      }\n\n    case 'refresh_failed':\n      {\n        return Object.assign(Object.assign({}, state), {\n          refreshTokenState: types_1.RefreshTokenState.FAILED,\n          gatewayStatus: (0, utils_1.statusFromToken)(state, state.gatewayToken),\n          civicPass: Object.assign(Object.assign({}, state.civicPass), {\n            responsePayload: undefined\n          })\n        });\n      }\n\n    case 'refresh_with_powo_in_progress':\n      {\n        return Object.assign(Object.assign({}, state), {\n          renderIframe: false,\n          iframeMinimized: true,\n          gatewayStatus: types_1.GatewayStatus.CHECKING\n        });\n      }\n\n    case 'refresh_clear_timeout':\n      return Object.assign(Object.assign({}, state), {\n        refreshTimeoutId: undefined\n      });\n\n    case 'refresh_set_timeout':\n      return Object.assign(Object.assign({}, state), {\n        refreshTimeoutId: action.refreshTimeoutId\n      });\n\n    case 'refresh_token_success':\n      return Object.assign(Object.assign({}, state), {\n        refreshTokenState: types_1.RefreshTokenState.WAIT_FOR_ON_CHAIN\n      });\n\n    default:\n      return state;\n  }\n};\n\nexports.reducer = reducer;\n\nconst useRefresh = (_ref, state, dispatch) => {\n  let {\n    stage,\n    gatekeeperClient,\n    networkConfig\n  } = _ref;\n  const {\n    refreshTimeoutId,\n    gatewayToken,\n    gatekeeperNetworkAddress,\n    ownerSigns,\n    walletAddress\n  } = state;\n\n  const logDebug = function (message) {\n    let obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger_1.default.debug(`[useRefresh] ${message}`, obj);\n  };\n\n  const setTimeoutForRefresh = (0, react_1.useRef)(null);\n  /**\n   * Start a timeout based on the expiration of the GatewayToken that will check if a token needs to be refreshed\n   * event, triggering the refreshFlow\n   */\n\n  const checkForRefreshWithTimeout = (0, react_1.useCallback)(() => {\n    logDebug('Checking if refresh required', refreshTimeoutId);\n    dispatch({\n      type: 'refresh_status_check'\n    });\n\n    if (!refreshTimeoutId && (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime)) {\n      const {\n        tokenExpirationMarginSeconds\n      } = networkConfig;\n      const checkForExpirationIntervalMilliseconds = (0, tokenUtils_1.getTokenRefreshIntervalMilliseconds)(gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime, tokenExpirationMarginSeconds);\n      const timeoutId = setTimeout(() => {\n        const shouldRefresh = (0, tokenUtils_1.isTokenRefreshRequired)({\n          gatewayToken,\n          tokenExpirationMarginSeconds\n        });\n\n        if (shouldRefresh) {\n          logDebug('Refreshing Gateway Token');\n          dispatch({\n            type: 'refresh_start'\n          });\n          dispatch({\n            type: 'civicPass_check_token_status'\n          });\n          return;\n        }\n\n        logDebug('Skipping refresh', {\n          gatewayToken,\n          tokenExpirationMarginSeconds\n        });\n        dispatch({\n          type: 'refresh_complete'\n        });\n      }, checkForExpirationIntervalMilliseconds); // this will be cleared on completion\n\n      logDebug('Setting token refresh timeout', {\n        expiring: gatewayToken.expiryTime,\n        checkForExpirationIntervalMilliseconds,\n        margin: tokenExpirationMarginSeconds\n      });\n      dispatch({\n        type: 'refresh_set_timeout',\n        refreshTimeoutId: timeoutId\n      });\n    }\n  }, [refreshTimeoutId, stage, gatewayToken, networkConfig.tokenExpirationMarginSeconds]);\n  /**\n   * use the passed proof of wallet ownership string to call the gatekeeper refresh token\n   * endpoint.\n   * On server error (5xx), retry with backoff.\n   * On all other errors, e.g. 400, move to a REFRESH_FAILED state.\n   */\n\n  const refreshToken = (0, react_1.useCallback)(useWallet => async _ref2 => {\n    let {\n      proof,\n      payload\n    } = _ref2;\n    logDebug('Refresh token', {\n      payload,\n      proof\n    });\n    dispatch({\n      type: 'refresh_with_powo_in_progress'\n    });\n    const refreshResult = await gatekeeperClient().refreshToken({\n      wallet: useWallet,\n      payload,\n      proof,\n      ownerSigns: ownerSigns !== null && ownerSigns !== void 0 ? ownerSigns : false\n    });\n    dispatch({\n      type: 'refresh_token_success'\n    });\n    return refreshResult.transaction;\n  }, [gatewayToken, gatekeeperClient, checkForRefreshWithTimeout, ownerSigns, walletAddress]);\n  /**\n   * wait until a gateway token exists in state before resolving the promise\n   */\n\n  const waitForUnexpiredGatewayToken = (0, react_1.useCallback)(() => {\n    return new Promise((resolve, reject) => {\n      logDebug('Waiting for unexpired token');\n\n      if (setTimeoutForRefresh.current) {\n        logDebug('Clearing interval for gatewayToken', setTimeoutForRefresh.current);\n        clearTimeout(setTimeoutForRefresh.current);\n        setTimeoutForRefresh.current = null;\n      }\n\n      const isExpired = (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime) && (0, tokenUtils_1.hasExpired)(gatewayToken.expiryTime);\n\n      if (!isExpired) {\n        logDebug('Gateway token is unexpired', gatewayToken);\n        resolve();\n        return;\n      }\n\n      setTimeoutForRefresh.current = setTimeout(() => {\n        reject(new Error('Gateway token refresh has not been updated onChain'));\n      }, networkConfig.waitForTokenRefreshTimoutMilliseconds);\n      logDebug('Starting check for Gateway token expiration timeout with identifier', setTimeoutForRefresh.current);\n    });\n  }, [gatewayToken, setTimeoutForRefresh, gatekeeperNetworkAddress]);\n  return {\n    checkForRefreshWithTimeout,\n    refreshToken,\n    waitForUnexpiredGatewayToken\n  };\n};\n\nexports.default = useRefresh;","map":{"version":3,"sources":["/Users/ashish/Desktop/Hacknsut/Nfts/mint/metaplex/js/packages/candy-machine-ui/node_modules/@civic/solana-gateway-react/dist/esm/useHooks/useRefresh.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","reducer","react_1","require","utils_1","logger_1","types_1","tokenUtils_1","state","action","type","assign","walletPowoInProgress","powoFinished","powoRequested","undefined","refreshInProgress","gatewayStatus","GatewayStatus","REFRESH_TOKEN_REQUIRED","refreshTokenState","RefreshTokenState","IN_PROGRESS","COMPLETED","statusFromToken","gatewayToken","refreshTimeoutId","civicPass","responsePayload","FAILED","renderIframe","iframeMinimized","CHECKING","WAIT_FOR_ON_CHAIN","useRefresh","dispatch","stage","gatekeeperClient","networkConfig","gatekeeperNetworkAddress","ownerSigns","walletAddress","logDebug","message","obj","default","debug","setTimeoutForRefresh","useRef","checkForRefreshWithTimeout","useCallback","expiryTime","tokenExpirationMarginSeconds","checkForExpirationIntervalMilliseconds","getTokenRefreshIntervalMilliseconds","timeoutId","setTimeout","shouldRefresh","isTokenRefreshRequired","expiring","margin","refreshToken","useWallet","proof","payload","refreshResult","wallet","transaction","waitForUnexpiredGatewayToken","Promise","resolve","reject","current","clearTimeout","isExpired","hasExpired","Error","waitForTokenRefreshTimoutMilliseconds"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reducer = void 0;\nconst react_1 = require(\"react\");\nconst utils_1 = require(\"../useReducer/utils\");\nconst logger_1 = __importDefault(require(\"../logger\"));\nconst types_1 = require(\"../types\");\nconst tokenUtils_1 = require(\"../utils/tokenUtils\");\nconst reducer = (state, action) => {\n    switch (action.type) {\n        case 'refresh_start': {\n            return Object.assign(Object.assign({}, state), { walletPowoInProgress: false, powoFinished: false, powoRequested: undefined, refreshInProgress: true, gatewayStatus: types_1.GatewayStatus.REFRESH_TOKEN_REQUIRED });\n        }\n        case 'refresh_status_check': {\n            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.IN_PROGRESS });\n        }\n        case 'refresh_complete': {\n            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.COMPLETED, gatewayStatus: (0, utils_1.statusFromToken)(state, state.gatewayToken), refreshTimeoutId: undefined, civicPass: Object.assign(Object.assign({}, state.civicPass), { responsePayload: undefined }) });\n        }\n        case 'refresh_failed': {\n            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.FAILED, gatewayStatus: (0, utils_1.statusFromToken)(state, state.gatewayToken), civicPass: Object.assign(Object.assign({}, state.civicPass), { responsePayload: undefined }) });\n        }\n        case 'refresh_with_powo_in_progress': {\n            return Object.assign(Object.assign({}, state), { renderIframe: false, iframeMinimized: true, gatewayStatus: types_1.GatewayStatus.CHECKING });\n        }\n        case 'refresh_clear_timeout':\n            return Object.assign(Object.assign({}, state), { refreshTimeoutId: undefined });\n        case 'refresh_set_timeout':\n            return Object.assign(Object.assign({}, state), { refreshTimeoutId: action.refreshTimeoutId });\n        case 'refresh_token_success':\n            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.WAIT_FOR_ON_CHAIN });\n        default:\n            return state;\n    }\n};\nexports.reducer = reducer;\nconst useRefresh = ({ stage, gatekeeperClient, networkConfig, }, state, dispatch) => {\n    const { refreshTimeoutId, gatewayToken, gatekeeperNetworkAddress, ownerSigns, walletAddress } = state;\n    const logDebug = (message, obj = null) => logger_1.default.debug(`[useRefresh] ${message}`, obj);\n    const setTimeoutForRefresh = (0, react_1.useRef)(null);\n    /**\n     * Start a timeout based on the expiration of the GatewayToken that will check if a token needs to be refreshed\n     * event, triggering the refreshFlow\n     */\n    const checkForRefreshWithTimeout = (0, react_1.useCallback)(() => {\n        logDebug('Checking if refresh required', refreshTimeoutId);\n        dispatch({ type: 'refresh_status_check' });\n        if (!refreshTimeoutId && (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime)) {\n            const { tokenExpirationMarginSeconds } = networkConfig;\n            const checkForExpirationIntervalMilliseconds = (0, tokenUtils_1.getTokenRefreshIntervalMilliseconds)(gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime, tokenExpirationMarginSeconds);\n            const timeoutId = setTimeout(() => {\n                const shouldRefresh = (0, tokenUtils_1.isTokenRefreshRequired)({ gatewayToken, tokenExpirationMarginSeconds });\n                if (shouldRefresh) {\n                    logDebug('Refreshing Gateway Token');\n                    dispatch({ type: 'refresh_start' });\n                    dispatch({ type: 'civicPass_check_token_status' });\n                    return;\n                }\n                logDebug('Skipping refresh', { gatewayToken, tokenExpirationMarginSeconds });\n                dispatch({ type: 'refresh_complete' });\n            }, checkForExpirationIntervalMilliseconds); // this will be cleared on completion\n            logDebug('Setting token refresh timeout', {\n                expiring: gatewayToken.expiryTime,\n                checkForExpirationIntervalMilliseconds,\n                margin: tokenExpirationMarginSeconds,\n            });\n            dispatch({\n                type: 'refresh_set_timeout',\n                refreshTimeoutId: timeoutId,\n            });\n        }\n    }, [refreshTimeoutId, stage, gatewayToken, networkConfig.tokenExpirationMarginSeconds]);\n    /**\n     * use the passed proof of wallet ownership string to call the gatekeeper refresh token\n     * endpoint.\n     * On server error (5xx), retry with backoff.\n     * On all other errors, e.g. 400, move to a REFRESH_FAILED state.\n     */\n    const refreshToken = (0, react_1.useCallback)((useWallet) => async ({ proof, payload }) => {\n        logDebug('Refresh token', { payload, proof });\n        dispatch({ type: 'refresh_with_powo_in_progress' });\n        const refreshResult = await gatekeeperClient().refreshToken({\n            wallet: useWallet,\n            payload,\n            proof,\n            ownerSigns: ownerSigns !== null && ownerSigns !== void 0 ? ownerSigns : false,\n        });\n        dispatch({ type: 'refresh_token_success' });\n        return refreshResult.transaction;\n    }, [gatewayToken, gatekeeperClient, checkForRefreshWithTimeout, ownerSigns, walletAddress]);\n    /**\n     * wait until a gateway token exists in state before resolving the promise\n     */\n    const waitForUnexpiredGatewayToken = (0, react_1.useCallback)(() => {\n        return new Promise((resolve, reject) => {\n            logDebug('Waiting for unexpired token');\n            if (setTimeoutForRefresh.current) {\n                logDebug('Clearing interval for gatewayToken', setTimeoutForRefresh.current);\n                clearTimeout(setTimeoutForRefresh.current);\n                setTimeoutForRefresh.current = null;\n            }\n            const isExpired = (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime) && (0, tokenUtils_1.hasExpired)(gatewayToken.expiryTime);\n            if (!isExpired) {\n                logDebug('Gateway token is unexpired', gatewayToken);\n                resolve();\n                return;\n            }\n            setTimeoutForRefresh.current = setTimeout(() => {\n                reject(new Error('Gateway token refresh has not been updated onChain'));\n            }, networkConfig.waitForTokenRefreshTimoutMilliseconds);\n            logDebug('Starting check for Gateway token expiration timeout with identifier', setTimeoutForRefresh.current);\n        });\n    }, [gatewayToken, setTimeoutForRefresh, gatekeeperNetworkAddress]);\n    return {\n        checkForRefreshWithTimeout,\n        refreshToken,\n        waitForUnexpiredGatewayToken,\n    };\n};\nexports.default = useRefresh;\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport BloctoSDK from '@blocto/sdk';\nimport { BaseWalletAdapter, WalletAccountError, WalletAdapterNetwork, WalletConnectionError, WalletDisconnectionError, WalletNotConnectedError, WalletNotFoundError, WalletPublicKeyError, WalletSendTransactionError } from '@solana/wallet-adapter-base';\nimport { PublicKey } from '@solana/web3.js';\nexport class BloctoWalletAdapter extends BaseWalletAdapter {\n  constructor() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this._connecting = false;\n    this._wallet = null;\n    this._publicKey = null;\n    this._network = config.network || WalletAdapterNetwork.Mainnet;\n  }\n\n  get publicKey() {\n    return this._publicKey;\n  }\n\n  get ready() {\n    return true;\n  }\n\n  get connecting() {\n    return this._connecting;\n  }\n\n  get connected() {\n    return !!this._publicKey;\n  }\n\n  connect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (this.connected || this.connecting) return;\n        this._connecting = true;\n        const wallet = new BloctoSDK({\n          solana: {\n            net: this._network\n          }\n        }).solana;\n        if (!wallet) throw new WalletNotFoundError();\n\n        if (!wallet.connected) {\n          try {\n            yield wallet.connect();\n          } catch (error) {\n            throw new WalletConnectionError(error === null || error === void 0 ? void 0 : error.message, error);\n          }\n        }\n\n        const account = wallet.accounts[0];\n        if (!account) throw new WalletAccountError();\n        let publicKey;\n\n        try {\n          publicKey = new PublicKey(account);\n        } catch (error) {\n          throw new WalletPublicKeyError(error === null || error === void 0 ? void 0 : error.message, error);\n        }\n\n        this._wallet = wallet;\n        this._publicKey = publicKey;\n        this.emit('connect');\n      } catch (error) {\n        this.emit('error', error);\n        throw error;\n      } finally {\n        this._connecting = false;\n      }\n    });\n  }\n\n  disconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const wallet = this._wallet;\n\n      if (wallet) {\n        this._wallet = null;\n        this._publicKey = null;\n\n        try {\n          yield wallet.disconnect();\n        } catch (error) {\n          this.emit('error', new WalletDisconnectionError(error === null || error === void 0 ? void 0 : error.message, error));\n        }\n      }\n\n      this.emit('disconnect');\n    });\n  }\n\n  sendTransaction(transaction, connection) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const wallet = this._wallet;\n        if (!wallet) throw new WalletNotConnectedError();\n\n        try {\n          transaction.feePayer || (transaction.feePayer = this.publicKey || undefined);\n          transaction.recentBlockhash || (transaction.recentBlockhash = (yield connection.getRecentBlockhash('finalized')).blockhash);\n          const {\n            signers\n          } = options;\n\n          if (signers === null || signers === void 0 ? void 0 : signers.length) {\n            transaction = yield wallet.convertToProgramWalletTransaction(transaction);\n            transaction.partialSign(...signers);\n          }\n\n          return yield wallet.signAndSendTransaction(transaction, connection);\n        } catch (error) {\n          throw new WalletSendTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n        }\n      } catch (error) {\n        this.emit('error', error);\n        throw error;\n      }\n    });\n  }\n\n}","map":{"version":3,"sources":["../src/adapter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport BloctoSDK from '@blocto/sdk';\nimport { BaseWalletAdapter, WalletAccountError, WalletAdapterNetwork, WalletConnectionError, WalletDisconnectionError, WalletNotConnectedError, WalletNotFoundError, WalletPublicKeyError, WalletSendTransactionError, } from '@solana/wallet-adapter-base';\nimport { PublicKey } from '@solana/web3.js';\nexport class BloctoWalletAdapter extends BaseWalletAdapter {\n    constructor(config = {}) {\n        super();\n        this._connecting = false;\n        this._wallet = null;\n        this._publicKey = null;\n        this._network = config.network || WalletAdapterNetwork.Mainnet;\n    }\n    get publicKey() {\n        return this._publicKey;\n    }\n    get ready() {\n        return true;\n    }\n    get connecting() {\n        return this._connecting;\n    }\n    get connected() {\n        return !!this._publicKey;\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (this.connected || this.connecting)\n                    return;\n                this._connecting = true;\n                const wallet = new BloctoSDK({ solana: { net: this._network } }).solana;\n                if (!wallet)\n                    throw new WalletNotFoundError();\n                if (!wallet.connected) {\n                    try {\n                        yield wallet.connect();\n                    }\n                    catch (error) {\n                        throw new WalletConnectionError(error === null || error === void 0 ? void 0 : error.message, error);\n                    }\n                }\n                const account = wallet.accounts[0];\n                if (!account)\n                    throw new WalletAccountError();\n                let publicKey;\n                try {\n                    publicKey = new PublicKey(account);\n                }\n                catch (error) {\n                    throw new WalletPublicKeyError(error === null || error === void 0 ? void 0 : error.message, error);\n                }\n                this._wallet = wallet;\n                this._publicKey = publicKey;\n                this.emit('connect');\n            }\n            catch (error) {\n                this.emit('error', error);\n                throw error;\n            }\n            finally {\n                this._connecting = false;\n            }\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const wallet = this._wallet;\n            if (wallet) {\n                this._wallet = null;\n                this._publicKey = null;\n                try {\n                    yield wallet.disconnect();\n                }\n                catch (error) {\n                    this.emit('error', new WalletDisconnectionError(error === null || error === void 0 ? void 0 : error.message, error));\n                }\n            }\n            this.emit('disconnect');\n        });\n    }\n    sendTransaction(transaction, connection, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const wallet = this._wallet;\n                if (!wallet)\n                    throw new WalletNotConnectedError();\n                try {\n                    transaction.feePayer || (transaction.feePayer = this.publicKey || undefined);\n                    transaction.recentBlockhash || (transaction.recentBlockhash = (yield connection.getRecentBlockhash('finalized')).blockhash);\n                    const { signers } = options;\n                    if (signers === null || signers === void 0 ? void 0 : signers.length) {\n                        transaction = yield wallet.convertToProgramWalletTransaction(transaction);\n                        transaction.partialSign(...signers);\n                    }\n                    return yield wallet.signAndSendTransaction(transaction, connection);\n                }\n                catch (error) {\n                    throw new WalletSendTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n                }\n            }\n            catch (error) {\n                this.emit('error', error);\n                throw error;\n            }\n        });\n    }\n}\n//# sourceMappingURL=adapter.js.map"]},"metadata":{},"sourceType":"module"}
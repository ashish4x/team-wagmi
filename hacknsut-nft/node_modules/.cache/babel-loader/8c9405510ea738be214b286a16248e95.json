{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport Wallet from '@project-serum/sol-wallet-adapter';\nimport { BaseMessageSignerWalletAdapter, pollUntilReady, WalletAdapterNetwork, WalletConnectionError, WalletDisconnectedError, WalletDisconnectionError, WalletError, WalletNotConnectedError, WalletNotFoundError, WalletSignMessageError, WalletSignTransactionError, WalletTimeoutError, WalletWindowBlockedError, WalletWindowClosedError } from '@solana/wallet-adapter-base';\nexport class SolletWalletAdapter extends BaseMessageSignerWalletAdapter {\n  constructor() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n\n    this._disconnected = () => {\n      const wallet = this._wallet;\n\n      if (wallet) {\n        wallet.off('disconnect', this._disconnected);\n        this._wallet = null;\n        this.emit('error', new WalletDisconnectedError());\n        this.emit('disconnect');\n      }\n    };\n\n    this._provider = config.provider || (typeof window === 'undefined' ? undefined : window.sollet);\n    this._network = config.network || WalletAdapterNetwork.Mainnet;\n    this._connecting = false;\n    this._wallet = null;\n    if (!this.ready) pollUntilReady(this, config.pollInterval || 1000, config.pollCount || 3);\n  }\n\n  get publicKey() {\n    var _a;\n\n    return ((_a = this._wallet) === null || _a === void 0 ? void 0 : _a.publicKey) || null;\n  }\n\n  get ready() {\n    var _a;\n\n    return typeof this._provider === 'string' || typeof window !== 'undefined' && typeof ((_a = window.sollet) === null || _a === void 0 ? void 0 : _a.postMessage) === 'function';\n  }\n\n  get connecting() {\n    return this._connecting;\n  }\n\n  get connected() {\n    var _a;\n\n    return !!((_a = this._wallet) === null || _a === void 0 ? void 0 : _a.connected);\n  }\n\n  connect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (this.connected || this.connecting) return;\n        this._connecting = true;\n        const provider = this._provider || typeof window !== 'undefined' && window.sollet;\n        if (!provider) throw new WalletNotFoundError();\n        let wallet;\n\n        try {\n          wallet = new Wallet(provider, this._network); // HACK: sol-wallet-adapter doesn't reject or emit an event if the popup or extension is closed or blocked\n\n          const handleDisconnect = wallet.handleDisconnect;\n          let timeout;\n          let interval;\n\n          try {\n            yield new Promise((resolve, reject) => {\n              const connect = () => {\n                if (timeout) clearTimeout(timeout);\n                wallet.off('connect', connect);\n                resolve();\n              };\n\n              wallet.handleDisconnect = function () {\n                wallet.off('connect', connect);\n                reject(new WalletWindowClosedError());\n\n                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                  args[_key] = arguments[_key];\n                }\n\n                return handleDisconnect.apply(wallet, args);\n              };\n\n              wallet.on('connect', connect);\n              wallet.connect().catch(reason => {\n                wallet.off('connect', connect);\n                reject(reason);\n              });\n\n              if (typeof provider === 'string') {\n                let count = 0;\n                interval = setInterval(() => {\n                  const popup = wallet._popup;\n\n                  if (popup) {\n                    if (popup.closed) reject(new WalletWindowClosedError());\n                  } else {\n                    if (count > 50) reject(new WalletWindowBlockedError());\n                  }\n\n                  count++;\n                }, 100);\n              } else {\n                // HACK: sol-wallet-adapter doesn't reject or emit an event if the extension is closed or ignored\n                timeout = setTimeout(() => reject(new WalletTimeoutError()), 10000);\n              }\n            });\n          } finally {\n            wallet.handleDisconnect = handleDisconnect;\n            if (interval) clearInterval(interval);\n          }\n        } catch (error) {\n          if (error instanceof WalletError) throw error;\n          throw new WalletConnectionError(error === null || error === void 0 ? void 0 : error.message, error);\n        }\n\n        wallet.on('disconnect', this._disconnected);\n        this._wallet = wallet;\n        this.emit('connect');\n      } catch (error) {\n        this.emit('error', error);\n        throw error;\n      } finally {\n        this._connecting = false;\n      }\n    });\n  }\n\n  disconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const wallet = this._wallet;\n\n      if (wallet) {\n        wallet.off('disconnect', this._disconnected);\n        this._wallet = null; // HACK: sol-wallet-adapter doesn't reliably fulfill its promise or emit an event on disconnect\n\n        const handleDisconnect = wallet.handleDisconnect;\n\n        try {\n          yield new Promise((resolve, reject) => {\n            const timeout = setTimeout(() => resolve(), 250);\n\n            wallet.handleDisconnect = function () {\n              clearTimeout(timeout);\n              resolve(); // HACK: sol-wallet-adapter rejects with an uncaught promise error\n\n              wallet._responsePromises = new Map();\n\n              for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                args[_key2] = arguments[_key2];\n              }\n\n              return handleDisconnect.apply(wallet, args);\n            };\n\n            wallet.disconnect().then(() => {\n              clearTimeout(timeout);\n              resolve();\n            }, error => {\n              clearTimeout(timeout); // HACK: sol-wallet-adapter rejects with an error on disconnect\n\n              if ((error === null || error === void 0 ? void 0 : error.message) === 'Wallet disconnected') {\n                resolve();\n              } else {\n                reject(error);\n              }\n            });\n          });\n        } catch (error) {\n          this.emit('error', new WalletDisconnectionError(error === null || error === void 0 ? void 0 : error.message, error));\n        } finally {\n          wallet.handleDisconnect = handleDisconnect;\n        }\n      }\n\n      this.emit('disconnect');\n    });\n  }\n\n  signTransaction(transaction) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const wallet = this._wallet;\n        if (!wallet) throw new WalletNotConnectedError();\n\n        try {\n          return (yield wallet.signTransaction(transaction)) || transaction;\n        } catch (error) {\n          throw new WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n        }\n      } catch (error) {\n        this.emit('error', error);\n        throw error;\n      }\n    });\n  }\n\n  signAllTransactions(transactions) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const wallet = this._wallet;\n        if (!wallet) throw new WalletNotConnectedError();\n\n        try {\n          return (yield wallet.signAllTransactions(transactions)) || transactions;\n        } catch (error) {\n          throw new WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n        }\n      } catch (error) {\n        this.emit('error', error);\n        throw error;\n      }\n    });\n  }\n\n  signMessage(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const wallet = this._wallet;\n        if (!wallet) throw new WalletNotConnectedError();\n\n        try {\n          const {\n            signature\n          } = yield wallet.sign(message, 'utf8');\n          return Uint8Array.from(signature);\n        } catch (error) {\n          throw new WalletSignMessageError(error === null || error === void 0 ? void 0 : error.message, error);\n        }\n      } catch (error) {\n        this.emit('error', error);\n        throw error;\n      }\n    });\n  }\n\n}","map":{"version":3,"sources":["../src/adapter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport Wallet from '@project-serum/sol-wallet-adapter';\nimport { BaseMessageSignerWalletAdapter, pollUntilReady, WalletAdapterNetwork, WalletConnectionError, WalletDisconnectedError, WalletDisconnectionError, WalletError, WalletNotConnectedError, WalletNotFoundError, WalletSignMessageError, WalletSignTransactionError, WalletTimeoutError, WalletWindowBlockedError, WalletWindowClosedError, } from '@solana/wallet-adapter-base';\nexport class SolletWalletAdapter extends BaseMessageSignerWalletAdapter {\n    constructor(config = {}) {\n        super();\n        this._disconnected = () => {\n            const wallet = this._wallet;\n            if (wallet) {\n                wallet.off('disconnect', this._disconnected);\n                this._wallet = null;\n                this.emit('error', new WalletDisconnectedError());\n                this.emit('disconnect');\n            }\n        };\n        this._provider = config.provider || (typeof window === 'undefined' ? undefined : window.sollet);\n        this._network = config.network || WalletAdapterNetwork.Mainnet;\n        this._connecting = false;\n        this._wallet = null;\n        if (!this.ready)\n            pollUntilReady(this, config.pollInterval || 1000, config.pollCount || 3);\n    }\n    get publicKey() {\n        var _a;\n        return ((_a = this._wallet) === null || _a === void 0 ? void 0 : _a.publicKey) || null;\n    }\n    get ready() {\n        var _a;\n        return (typeof this._provider === 'string' ||\n            (typeof window !== 'undefined' && typeof ((_a = window.sollet) === null || _a === void 0 ? void 0 : _a.postMessage) === 'function'));\n    }\n    get connecting() {\n        return this._connecting;\n    }\n    get connected() {\n        var _a;\n        return !!((_a = this._wallet) === null || _a === void 0 ? void 0 : _a.connected);\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (this.connected || this.connecting)\n                    return;\n                this._connecting = true;\n                const provider = this._provider || (typeof window !== 'undefined' && window.sollet);\n                if (!provider)\n                    throw new WalletNotFoundError();\n                let wallet;\n                try {\n                    wallet = new Wallet(provider, this._network);\n                    // HACK: sol-wallet-adapter doesn't reject or emit an event if the popup or extension is closed or blocked\n                    const handleDisconnect = wallet.handleDisconnect;\n                    let timeout;\n                    let interval;\n                    try {\n                        yield new Promise((resolve, reject) => {\n                            const connect = () => {\n                                if (timeout)\n                                    clearTimeout(timeout);\n                                wallet.off('connect', connect);\n                                resolve();\n                            };\n                            wallet.handleDisconnect = (...args) => {\n                                wallet.off('connect', connect);\n                                reject(new WalletWindowClosedError());\n                                return handleDisconnect.apply(wallet, args);\n                            };\n                            wallet.on('connect', connect);\n                            wallet.connect().catch((reason) => {\n                                wallet.off('connect', connect);\n                                reject(reason);\n                            });\n                            if (typeof provider === 'string') {\n                                let count = 0;\n                                interval = setInterval(() => {\n                                    const popup = wallet._popup;\n                                    if (popup) {\n                                        if (popup.closed)\n                                            reject(new WalletWindowClosedError());\n                                    }\n                                    else {\n                                        if (count > 50)\n                                            reject(new WalletWindowBlockedError());\n                                    }\n                                    count++;\n                                }, 100);\n                            }\n                            else {\n                                // HACK: sol-wallet-adapter doesn't reject or emit an event if the extension is closed or ignored\n                                timeout = setTimeout(() => reject(new WalletTimeoutError()), 10000);\n                            }\n                        });\n                    }\n                    finally {\n                        wallet.handleDisconnect = handleDisconnect;\n                        if (interval)\n                            clearInterval(interval);\n                    }\n                }\n                catch (error) {\n                    if (error instanceof WalletError)\n                        throw error;\n                    throw new WalletConnectionError(error === null || error === void 0 ? void 0 : error.message, error);\n                }\n                wallet.on('disconnect', this._disconnected);\n                this._wallet = wallet;\n                this.emit('connect');\n            }\n            catch (error) {\n                this.emit('error', error);\n                throw error;\n            }\n            finally {\n                this._connecting = false;\n            }\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const wallet = this._wallet;\n            if (wallet) {\n                wallet.off('disconnect', this._disconnected);\n                this._wallet = null;\n                // HACK: sol-wallet-adapter doesn't reliably fulfill its promise or emit an event on disconnect\n                const handleDisconnect = wallet.handleDisconnect;\n                try {\n                    yield new Promise((resolve, reject) => {\n                        const timeout = setTimeout(() => resolve(), 250);\n                        wallet.handleDisconnect = (...args) => {\n                            clearTimeout(timeout);\n                            resolve();\n                            // HACK: sol-wallet-adapter rejects with an uncaught promise error\n                            wallet._responsePromises = new Map();\n                            return handleDisconnect.apply(wallet, args);\n                        };\n                        wallet.disconnect().then(() => {\n                            clearTimeout(timeout);\n                            resolve();\n                        }, (error) => {\n                            clearTimeout(timeout);\n                            // HACK: sol-wallet-adapter rejects with an error on disconnect\n                            if ((error === null || error === void 0 ? void 0 : error.message) === 'Wallet disconnected') {\n                                resolve();\n                            }\n                            else {\n                                reject(error);\n                            }\n                        });\n                    });\n                }\n                catch (error) {\n                    this.emit('error', new WalletDisconnectionError(error === null || error === void 0 ? void 0 : error.message, error));\n                }\n                finally {\n                    wallet.handleDisconnect = handleDisconnect;\n                }\n            }\n            this.emit('disconnect');\n        });\n    }\n    signTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const wallet = this._wallet;\n                if (!wallet)\n                    throw new WalletNotConnectedError();\n                try {\n                    return (yield wallet.signTransaction(transaction)) || transaction;\n                }\n                catch (error) {\n                    throw new WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n                }\n            }\n            catch (error) {\n                this.emit('error', error);\n                throw error;\n            }\n        });\n    }\n    signAllTransactions(transactions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const wallet = this._wallet;\n                if (!wallet)\n                    throw new WalletNotConnectedError();\n                try {\n                    return (yield wallet.signAllTransactions(transactions)) || transactions;\n                }\n                catch (error) {\n                    throw new WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n                }\n            }\n            catch (error) {\n                this.emit('error', error);\n                throw error;\n            }\n        });\n    }\n    signMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const wallet = this._wallet;\n                if (!wallet)\n                    throw new WalletNotConnectedError();\n                try {\n                    const { signature } = yield wallet.sign(message, 'utf8');\n                    return Uint8Array.from(signature);\n                }\n                catch (error) {\n                    throw new WalletSignMessageError(error === null || error === void 0 ? void 0 : error.message, error);\n                }\n            }\n            catch (error) {\n                this.emit('error', error);\n                throw error;\n            }\n        });\n    }\n}\n//# sourceMappingURL=adapter.js.map"]},"metadata":{},"sourceType":"module"}